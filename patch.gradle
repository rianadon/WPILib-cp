/**
 * This build script takes care of patching the wpilib source.
 **/

buildscript {
    repositories { mavenCentral() }
    dependencies {
        classpath 'com.github.javaparser:javaparser-core:3.2.1'
        classpath 'de.danielbechler:java-object-diff:0.94'
    }
}

import com.github.javaparser.*
import com.github.javaparser.ast.*
import com.github.javaparser.ast.body.*
import com.github.javaparser.ast.comments.*
import com.github.javaparser.ast.expr.*
import com.github.javaparser.ast.nodeTypes.*
import com.github.javaparser.ast.stmt.*
import com.github.javaparser.ast.type.*
import com.github.javaparser.ast.visitor.*

import de.danielbechler.diff.*
import de.danielbechler.diff.comparison.*
import de.danielbechler.diff.introspection.*
import de.danielbechler.diff.instantiation.*
import de.danielbechler.diff.node.*

/**
 * This class finds all methods marked as native and gives the a default body.
 */
class BodyAdder extends VoidVisitorAdapter {
    @Override
    void visit(MethodDeclaration m, Object arg) {
        if (m.native) {
            m.native = false

            // Mark the method as a generated stub for later use
            m.javadocComment = ' Generated method stub '

            def body = m.body = new BlockStmt()

            // Add a println() to the method so we know
            // when an autogenerated method gets called
            def call = JavaParser.parseStatement genPrintStatement(m)
            body.statements << call

            // Return something so the method compiles
            def retVal = getDefault(m.type)
            if (retVal != null)
                body.statements << new ReturnStmt(retVal)
        }
    }

    String genPrintStatement(MethodDeclaration m) {
        // Find the class that defined the method
        def parentClass = m.parentNode.get()

        def pList = m.parameters.collect {
            if (it.type instanceof ArrayType)
                return "+ \"${it.name}=[...]\""
            else
                return "+ \"${it.name}=\"+${it.name}"
        }

        return "System.out.println(\"${parentClass.name}.${m.name}(\" " +
                String.join(' +", "', pList) +
                " + \");\");"
    }

    Expression getDefault(Type type) {
        switch (type.toString()) {
            case 'String':  return new StringLiteralExpr('')
            case 'boolean': return new BooleanLiteralExpr(false)
            case 'int':     return new IntegerLiteralExpr(0)
            case 'short':   return new IntegerLiteralExpr(0)
            case 'byte':    return new IntegerLiteralExpr(0)
            case 'long':    return new LongLiteralExpr(0)
            case 'double':  return new DoubleLiteralExpr(0)
            case 'void':    return null
            case 'PWMConfigDataResult': return new NullLiteralExpr()
            default:        throw new Error("No default value for type $type")
        }
    }
}

// Adds bodies to the file
ext.patchFile = { file ->
    def inp = file.newInputStream()
    def cu = JavaParser.parse(inp)
    inp.close()
    new BodyAdder().visit(cu, null)

    file.newWriter().withWriter { w ->
        w << cu.toString()
    }
}

// The diffing library wants to know how to traverse the AST,
// so tell it to use the getChildNodes() method
class NodeIntrospector implements Introspector {
    @Override
    public TypeInfo introspect(Class<?> type) {
        def typeInfo = new TypeInfo(type)
        def accessor = new PropertyAccessor('cn', type.getMethod('getChildNodes'), null)
        typeInfo.addPropertyAccessor(accessor)
        return typeInfo
    }
}

/**
 * A wrapper for Node objects that changes the .equals() property as well as a few more.
 * This is needed because there is no way to give a custom equals method to the differ,
 * and the equals method needs to be overriden so methods with the same name and parameters
 * but different bodies are still treated as equal.
 **/
class ModdedNode {
    private com.github.javaparser.ast.Node node

    public ModdedNode(com.github.javaparser.ast.Node n) {
        node = n
    }

    public com.github.javaparser.ast.Node getNode() {
        return node
    }

    public List<ModdedNode> getChildNodes() {
        return node.childNodes.collect { new ModdedNode(it) }
    }

    public boolean isGeneratedMethod() {
        return (node instanceof MethodDeclaration) && node.javadocComment.toString().contains(' Generated method stub ')
    }

    public boolean equals(Object o) {
        def c = o.node
        if (node instanceof ClassOrInterfaceDeclaration && c instanceof ClassOrInterfaceDeclaration)
            return node.name == c.name
        if (node instanceof MethodDeclaration && c instanceof MethodDeclaration) {
            if (node.name != c.name)
                return false
            for (int i = 0; i < Math.min(node.parameters.size(), c.parameters.size()); i++)
                if (!node.parameters[i].type == c.parameters[i].type)
                    return false
            return true
        }
        if (node instanceof InitializerDeclaration && c instanceof InitializerDeclaration)
            return node.isStatic() == c.isStatic()
        return node == c
    }

    public String toString() {
        return node instanceof NodeWithSimpleName ? node.name : node.toString()
    }
}

class ModifierVisitor implements DiffNode.Visitor {
    private ModdedNode base
    private ModdedNode working
    private boolean handleDeletions
    private boolean forwards

    public ModifierVisitor(ModdedNode b, ModdedNode w, boolean hd, boolean f) {
        base = b; working = w; handleDeletions = hd; forwards = f
    }

    public void node(DiffNode node, Visit visit) {
        def baseVal = node.canonicalGet base
        def workingVal = node.canonicalGet working

        // Because the diff tree contains both nodes and arrays of child nodes,
        // the nodes need to be filtered out so they can be processed
        if (!(baseVal == null || baseVal instanceof ModdedNode) || !(workingVal == null || workingVal instanceof ModdedNode))
            return

        // To make things simpler don't handle comments as they're not compiled anyways
        if (baseVal?.node instanceof Comment || workingVal?.node instanceof Comment)
            return

        // Also don't handle annotations as they are dealt with in other ways
        if (baseVal?.node instanceof AnnotationExpr || workingVal?.node instanceof AnnotationExpr)
            return

        if (handleDeletions || node.isRemoved())
            println "${node.getPath()} => ${node.getState()}"

        // Get parent nodes
        def bpVal = node.parentNode?.parentNode?.canonicalGet base
        def wpVal = node.parentNode?.parentNode?.canonicalGet working

        if (node.isChanged()) {
            // Update the javadoc if there is one
            if (baseVal.node instanceof NodeWithJavadoc)
                if (workingVal.node.hasJavaDocComment())
                    baseVal.node.javadocComment = workingVal.node.javadocComment.get()
                else
                    baseVal.node.removeJavaDocComment()

            // Same with annotations
            if (baseVal.node instanceof BodyDeclaration)
                baseVal.node.annotations = workingVal.node.annotations

            if (!workingVal.isGeneratedMethod()) {
                // Case 1: The method was implemented in the patch
                // In this case replace the method with the new version
                node.visitChildren(new ModifierVisitor(base, working, true, true))
                visit.dontGoDeeper()
            } else if(workingVal.node instanceof MethodDeclaration) {
                // Case 2: The patch did not implement the method
                // In this case replace the method with the old version
                node.visitChildren(new ModifierVisitor(base, working, true, false))
                visit.dontGoDeeper()
            } else {
                if (node.hasChildren()) {
                    // Visit children two levels down
                    def that = this
					node.visitChildren(new DiffNode.Visitor() {
                        public void node(DiffNode node2, Visit visit2) {
                            node2.visitChildren(that)
                        }
                    })
					visit.dontGoDeeper()
				} else {
                    def nodeIndex = bpVal.node.childNodes.indexOf(baseVal.node)
                    bpVal.node.childNodes[nodeIndex] = workingVal
				}
            }
        } else if (node.isAdded()) {
            if (forwards) {
                if (bpVal.node instanceof NodeWithMembers) {
                    def bList = bpVal.node.members
                    def wList = wpVal.node.members
                    def nodeIndex = wList.indexOf(workingVal.node)
                    bList.add(nodeIndex, workingVal.node)
                } else if (bpVal.node instanceof CompilationUnit && workingVal.node instanceof ImportDeclaration) {
                    def bList = bpVal.node.imports
                    def wList = wpVal.node.imports
                    def nodeIndex = wList.indexOf(workingVal.node)
                    bList.add(nodeIndex, workingVal.node)
                }
                else if (bpVal.node instanceof NodeWithBlockStmt)
                    bpVal.node.body = workingVal.node
                else if (bpVal.node instanceof NodeWithOptionalBlockStmt)
                    bpVal.node.body = workingVal.node
                else
                    println bpVal.node.class
            }
            visit.dontGoDeeper()
        } else if (node.isRemoved()) {
            visit.dontGoDeeper()
        }
    }
}

def objectDifferBuilder = ObjectDifferBuilder.startBuilding()
objectDifferBuilder.introspection().defaultIntrospector = new NodeIntrospector()

ext.patchMethods = { baseFile, workingFile, writeFile ->
    def bis = baseFile.newInputStream()
    def wis = workingFile.newInputStream()
    def base = new ModdedNode(JavaParser.parse(bis))
    def working = new ModdedNode(JavaParser.parse(wis))
    bis.close()
    wis.close()

    def diff = objectDifferBuilder.build().compare(working, base)
    diff.visit(new ModifierVisitor(base, working, false, true))

    writeFile.newWriter().withWriter { w ->
        w << base.toString()
    }
}
